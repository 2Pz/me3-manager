"""
TOML config (me3.toml) writer utility for ME3 Manager.
Handles writing ME3 config files while preserving comments and formatting using tomlkit.
"""

from pathlib import Path
from typing import Any

import tomlkit


class TomlConfigWriter:
    """Handles writing ME3 config files with comment preservation using tomlkit."""

    @staticmethod
    def _load_existing_config(config_path: Path) -> tuple[dict, str]:
        """
        Load existing config data from a TOML file.

        Returns:
            Tuple of (data: dict, error_message: str). If error, data is empty dict.
        """
        if not config_path.exists():
            return {}, ""

        try:
            import tomllib

            with open(config_path, "rb") as f:
                return tomllib.load(f), ""
        except Exception as e:
            return {}, f"Failed to parse existing config file: {str(e)}"

    @staticmethod
    def _write_toml_document(config_path: Path, data: dict) -> tuple[bool, str]:
        """
        Write data to a TOML file with standard header comment.

        Returns:
            Tuple of (success: bool, error_message: str)
        """
        doc = tomlkit.document()
        doc.add(tomlkit.comment("ME3 configuration file generated by ME3 Manager"))
        doc.add(tomlkit.nl())

        for k, v in data.items():
            doc[k] = v

        try:
            config_path.parent.mkdir(parents=True, exist_ok=True)
            with open(config_path, "w", encoding="utf-8") as f:
                f.write(tomlkit.dumps(doc))
            return True, ""
        except PermissionError:
            return False, f"Permission denied: Cannot write to {config_path}"
        except OSError as e:
            return False, f"OS error writing to {config_path}: {str(e)}"

    @staticmethod
    def update_config_value(
        config_path: Path, key: str, value: Any, section: str | None = None
    ) -> tuple[bool, str]:
        """
        Update a single value in a TOML config file while preserving comments and formatting.

        Args:
            config_path: Path to the TOML config file
            key: The key to update
            value: The new value (None to remove the key)
            section: Optional section name (e.g., "game.elden_ring")

        Returns:
            Tuple of (success: bool, error_message: str)
        """
        try:
            existing_data, error = TomlConfigWriter._load_existing_config(config_path)
            if error:
                return False, error

            # Navigate to the correct section and update the value
            if section:
                section_parts = section.split(".")
                current_section = existing_data
                for part in section_parts:
                    if part not in current_section:
                        current_section[part] = {}
                    current_section = current_section[part]

                # Update or remove the value
                if value is None:
                    current_section.pop(key, None)
                else:
                    current_section[key] = value
            else:
                # Update at root level
                if value is None:
                    existing_data.pop(key, None)
                else:
                    existing_data[key] = value

            return TomlConfigWriter._write_toml_document(config_path, existing_data)

        except Exception as e:
            return False, f"Unexpected error updating config: {str(e)}"

    @staticmethod
    def update_game_settings(
        config_path: Path, game_name: str, settings: dict[str, Any]
    ) -> tuple[bool, str]:
        """
        Update game-specific settings in the [game.gamename] section.

        Args:
            config_path: Path to the TOML config file
            game_name: Name of the game
            settings: Dictionary of settings to update

        Returns:
            Tuple of (success: bool, error_message: str)
        """
        try:
            existing_data, error = TomlConfigWriter._load_existing_config(config_path)
            if error:
                return False, error

            # Ensure game section exists in data
            if "game" not in existing_data:
                existing_data["game"] = {}

            if game_name not in existing_data["game"]:
                existing_data["game"][game_name] = {}

            # Update all settings in the data
            for k, v in settings.items():
                if v is None:
                    existing_data["game"][game_name].pop(k, None)
                else:
                    existing_data["game"][game_name][k] = v

            # Clean up empty sections
            if not existing_data["game"][game_name]:
                existing_data["game"].pop(game_name, None)
            if not existing_data.get("game"):
                existing_data.pop("game", None)

            return TomlConfigWriter._write_toml_document(config_path, existing_data)

        except Exception as e:
            return False, f"Unexpected error updating game settings: {str(e)}"

    @staticmethod
    def validate_write_access(config_path: Path) -> tuple[bool, str]:
        """
        Validate that we can write to the given config path.

        Args:
            config_path: Path to validate

        Returns:
            Tuple of (can_write: bool, error_message: str)
        """
        try:
            if config_path.exists():
                # File exists, check if we can write to it
                try:
                    with open(config_path, "a", encoding="utf-8"):
                        pass
                    return True, ""
                except PermissionError:
                    return (
                        False,
                        f"Permission denied: Cannot write to existing file {config_path}",
                    )
                except OSError as e:
                    return False, f"OS error accessing {config_path}: {str(e)}"
            else:
                # File doesn't exist, check if we can create it
                try:
                    config_path.parent.mkdir(parents=True, exist_ok=True)
                    # Test by creating a temporary file
                    with open(config_path, "w", encoding="utf-8") as f:
                        f.write("")
                    config_path.unlink()  # Remove the test file
                    return True, ""
                except PermissionError:
                    return (
                        False,
                        f"Permission denied: Cannot create file at {config_path}",
                    )
                except OSError as e:
                    return False, f"OS error creating {config_path}: {str(e)}"

        except Exception as e:
            return False, f"Unexpected error validating write access: {str(e)}"

    @staticmethod
    def is_system_path(file_path: Path) -> bool:
        """
        Check if a path is in a system directory that requires root privileges.

        Args:
            file_path: Path to check

        Returns:
            True if the path is in a system directory
        """
        system_prefixes = ["/etc/", "/usr/", "/opt/", "/var/lib/", "/var/opt/"]
        str_path = str(file_path)
        return any(str_path.startswith(prefix) for prefix in system_prefixes)
