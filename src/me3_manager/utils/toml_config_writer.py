"""
TOML config (me3.toml) writer utility for ME3 Manager.
Handles writing ME3 config files while preserving comments and formatting using tomlkit.
"""

from pathlib import Path
from typing import Any, Dict, Optional, Tuple

import tomlkit


class TomlConfigWriter:
    """Handles writing ME3 config files with comment preservation using tomlkit."""

    @staticmethod
    def update_config_value(
        config_path: Path, key: str, value: Any, section: Optional[str] = None
    ) -> Tuple[bool, str]:
        """
        Update a single value in a TOML config file while preserving comments and formatting.

        Args:
            config_path: Path to the TOML config file
            key: The key to update
            value: The new value (None to remove the key)
            section: Optional section name (e.g., "game.elden_ring")

        Returns:
            Tuple of (success: bool, error_message: str)
        """
        try:
            # Load existing data if file exists
            existing_data = {}
            if config_path.exists():
                try:
                    import tomllib

                    with open(config_path, "rb") as f:
                        existing_data = tomllib.load(f)
                except Exception as e:
                    return False, f"Failed to parse existing config file: {str(e)}"

            # Navigate to the correct section and update the value
            if section:
                section_parts = section.split(".")
                current_section = existing_data
                for part in section_parts:
                    if part not in current_section:
                        current_section[part] = {}
                    current_section = current_section[part]

                # Update or remove the value
                if value is None:
                    current_section.pop(key, None)
                else:
                    current_section[key] = value
            else:
                # Update at root level
                if value is None:
                    existing_data.pop(key, None)
                else:
                    existing_data[key] = value

            # Create a new TOML document from scratch
            doc = tomlkit.document()

            # Add header comment
            doc.add(tomlkit.comment("ME3 configuration file generated by ME3 Manager"))
            doc.add(tomlkit.nl())

            # Add all data to the document
            for k, v in existing_data.items():
                doc[k] = v

            # Write the file
            try:
                config_path.parent.mkdir(parents=True, exist_ok=True)
                with open(config_path, "w", encoding="utf-8") as f:
                    f.write(tomlkit.dumps(doc))
                return True, ""
            except PermissionError:
                return False, f"Permission denied: Cannot write to {config_path}"
            except OSError as e:
                return False, f"OS error writing to {config_path}: {str(e)}"

        except Exception as e:
            return False, f"Unexpected error updating config: {str(e)}"

    @staticmethod
    def update_game_settings(
        config_path: Path, game_name: str, settings: Dict[str, Any]
    ) -> Tuple[bool, str]:
        """
        Update game-specific settings in the [game.gamename] section.

        Args:
            config_path: Path to the TOML config file
            game_name: Name of the game
            settings: Dictionary of settings to update

        Returns:
            Tuple of (success: bool, error_message: str)
        """
        try:
            # Load existing data if file exists
            existing_data = {}
            if config_path.exists():
                try:
                    import tomllib

                    with open(config_path, "rb") as f:
                        existing_data = tomllib.load(f)
                except Exception as e:
                    return False, f"Failed to parse existing config file: {str(e)}"

            # Ensure game section exists in data
            if "game" not in existing_data:
                existing_data["game"] = {}

            if game_name not in existing_data["game"]:
                existing_data["game"][game_name] = {}

            # Update all settings in the data
            for k, v in settings.items():
                if v is None:
                    existing_data["game"][game_name].pop(k, None)
                else:
                    existing_data["game"][game_name][k] = v

            # Clean up empty sections
            if not existing_data["game"][game_name]:
                existing_data["game"].pop(game_name, None)
            if not existing_data.get("game"):
                existing_data.pop("game", None)

            # Create a new TOML document from scratch
            doc = tomlkit.document()

            # Add header comment
            doc.add(tomlkit.comment("ME3 configuration file generated by ME3 Manager"))
            doc.add(tomlkit.nl())

            # Add all data to the document
            for k, v in existing_data.items():
                doc[k] = v

            # Write the file
            try:
                config_path.parent.mkdir(parents=True, exist_ok=True)
                with open(config_path, "w", encoding="utf-8") as f:
                    f.write(tomlkit.dumps(doc))
                return True, ""
            except PermissionError:
                return False, f"Permission denied: Cannot write to {config_path}"
            except OSError as e:
                return False, f"OS error writing to {config_path}: {str(e)}"

        except Exception as e:
            return False, f"Unexpected error updating game settings: {str(e)}"

    @staticmethod
    def validate_write_access(config_path: Path) -> Tuple[bool, str]:
        """
        Validate that we can write to the given config path.

        Args:
            config_path: Path to validate

        Returns:
            Tuple of (can_write: bool, error_message: str)
        """
        try:
            if config_path.exists():
                # File exists, check if we can write to it
                try:
                    with open(config_path, "a", encoding="utf-8"):
                        pass
                    return True, ""
                except PermissionError:
                    return (
                        False,
                        f"Permission denied: Cannot write to existing file {config_path}",
                    )
                except OSError as e:
                    return False, f"OS error accessing {config_path}: {str(e)}"
            else:
                # File doesn't exist, check if we can create it
                try:
                    config_path.parent.mkdir(parents=True, exist_ok=True)
                    # Test by creating a temporary file
                    with open(config_path, "w", encoding="utf-8") as f:
                        f.write("")
                    config_path.unlink()  # Remove the test file
                    return True, ""
                except PermissionError:
                    return (
                        False,
                        f"Permission denied: Cannot create file at {config_path}",
                    )
                except OSError as e:
                    return False, f"OS error creating {config_path}: {str(e)}"

        except Exception as e:
            return False, f"Unexpected error validating write access: {str(e)}"

    @staticmethod
    def is_system_path(file_path: Path) -> bool:
        """
        Check if a path is in a system directory that requires root privileges.

        Args:
            file_path: Path to check

        Returns:
            True if the path is in a system directory
        """
        system_prefixes = ["/etc/", "/usr/", "/opt/", "/var/lib/", "/var/opt/"]
        str_path = str(file_path)
        return any(str_path.startswith(prefix) for prefix in system_prefixes)
