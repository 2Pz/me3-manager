"""
TOML profile writer for ME3 Manager.
Handles writing profile files with clean array of tables syntax using tomlkit.
"""

from pathlib import Path
from typing import Any, Dict, Optional

import tomlkit


class TomlProfileWriter:
    """Handles writing TOML profile files with clean formatting using tomlkit."""

    @staticmethod
    def write_profile(
        profile_path: Path,
        config_data: Dict[str, Any],
        game_name: Optional[str] = None,
    ) -> None:
        """
        Write a ME3 profile file with clean array of tables syntax using tomlkit.

        Args:
            profile_path: Path to write the profile to
            config_data: Dictionary containing profile data
            game_name: Optional game name for context
        """
        # Create a new TOML document
        doc = tomlkit.document()

        # Add header comment
        doc.add(tomlkit.comment("Profile generated by ME3 Manager"))
        doc.add("profileVersion", config_data.get("profileVersion", "v1"))

        # Add optional global settings
        if "savefile" in config_data and config_data["savefile"]:
            doc.add("savefile", config_data["savefile"])

        if "start_online" in config_data:
            doc.add("start_online", config_data["start_online"])

        # Add natives section
        natives = config_data.get("natives", [])
        if natives:
            natives_aot = tomlkit.aot()

            for native in natives:
                if isinstance(native, dict):
                    native_table = tomlkit.table()

                    # Add path (required)
                    if "path" in native:
                        native_table["path"] = native["path"]

                    # Add optional fields in a consistent order
                    if "optional" in native and native["optional"]:
                        native_table["optional"] = native["optional"]

                    if "initializer" in native:
                        # Handle initializer using dotted keys
                        initializer = native["initializer"]
                        if isinstance(initializer, dict):
                            if "function" in initializer:
                                native_table["initializer.function"] = initializer[
                                    "function"
                                ]
                            elif "delay" in initializer:
                                delay_data = initializer["delay"]
                                if isinstance(delay_data, dict):
                                    native_table["initializer.delay.ms"] = (
                                        delay_data.get("ms", 1000)
                                    )
                                else:
                                    # Simple delay value
                                    native_table["initializer.delay.ms"] = delay_data
                        else:
                            native_table["initializer"] = initializer

                    if "finalizer" in native:
                        # Handle finalizer using dotted keys if it's a dict, otherwise as string
                        finalizer = native["finalizer"]
                        if isinstance(finalizer, dict):
                            if "function" in finalizer:
                                native_table["finalizer.function"] = finalizer[
                                    "function"
                                ]
                        else:
                            native_table["finalizer"] = finalizer

                    # Handle load_before as simple string array
                    if "load_before" in native and native["load_before"]:
                        load_before_array = tomlkit.array()
                        for dep in native["load_before"]:
                            if isinstance(dep, dict):
                                # Extract the id from the dependency object
                                dep_id = dep.get("id", "")
                                if dep_id:
                                    load_before_array.append(dep_id)
                            else:
                                # Simple string format
                                load_before_array.append(str(dep))
                        native_table["load_before"] = load_before_array

                    # Handle load_after as simple string array
                    if "load_after" in native and native["load_after"]:
                        load_after_array = tomlkit.array()
                        for dep in native["load_after"]:
                            if isinstance(dep, dict):
                                # Extract the id from the dependency object
                                dep_id = dep.get("id", "")
                                if dep_id:
                                    load_after_array.append(dep_id)
                            else:
                                # Simple string format
                                load_after_array.append(str(dep))
                        native_table["load_after"] = load_after_array

                    natives_aot.append(native_table)

                elif isinstance(native, str):
                    # Simple string format
                    native_table = tomlkit.table()
                    native_table["path"] = native
                    natives_aot.append(native_table)

            doc.add("natives", natives_aot)

        # Add packages section
        packages = config_data.get("packages", [])
        if packages:
            packages_aot = tomlkit.aot()

            for package in packages:
                if isinstance(package, dict):
                    package_table = tomlkit.table()

                    # Add id if present
                    if "id" in package:
                        package_table["id"] = package["id"]

                    # Add path
                    if "path" in package:
                        package_table["path"] = package["path"]
                    elif "source" in package:
                        package_table["path"] = package["source"]

                    # Handle load_before as simple string array
                    if "load_before" in package and package["load_before"]:
                        load_before_array = tomlkit.array()
                        for dep in package["load_before"]:
                            if isinstance(dep, dict):
                                # Extract the id from the dependency object
                                dep_id = dep.get("id", "")
                                if dep_id:
                                    load_before_array.append(dep_id)
                            else:
                                # Simple string format
                                load_before_array.append(str(dep))
                        package_table["load_before"] = load_before_array

                    # Handle load_after as simple string array
                    if "load_after" in package and package["load_after"]:
                        load_after_array = tomlkit.array()
                        for dep in package["load_after"]:
                            if isinstance(dep, dict):
                                # Extract the id from the dependency object
                                dep_id = dep.get("id", "")
                                if dep_id:
                                    load_after_array.append(dep_id)
                            else:
                                # Simple string format
                                load_after_array.append(str(dep))
                        package_table["load_after"] = load_after_array

                    packages_aot.append(package_table)

            doc.add("packages", packages_aot)

        # Write to file
        with open(profile_path, "w", encoding="utf-8") as f:
            f.write(tomlkit.dumps(doc))

    @staticmethod
    def format_inline_to_aot(content: str) -> str:
        """
        Convert inline array syntax to array of tables syntax.
        This is a utility method for migrating existing profiles.

        Args:
            content: TOML content with inline arrays

        Returns:
            TOML content with array of tables
        """
        try:
            import tomllib

            # Parse the existing content
            config_data = tomllib.loads(content)

            # Use our writer to create the new format
            import tempfile

            with tempfile.NamedTemporaryFile(
                mode="w", suffix=".me3", delete=False
            ) as tmp:
                tmp_path = Path(tmp.name)

            try:
                TomlProfileWriter.write_profile(tmp_path, config_data)
                with open(tmp_path, "r", encoding="utf-8") as f:
                    result = f.read()
                return result
            finally:
                tmp_path.unlink(missing_ok=True)

        except Exception as e:
            print(f"Error converting TOML format: {e}")
            return content  # Return original if conversion fails
