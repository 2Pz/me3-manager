"""
TOML profile writer for ME3 Manager.
Handles writing profile files with clean array of tables syntax using tomlkit.
"""

import logging
from pathlib import Path
from typing import Any

import tomlkit
from tomlkit.items import Array

from .profile_converter import ProfileConverter

log = logging.getLogger(__name__)


class TomlProfileWriter:
    """Handles writing TOML profile files with clean formatting using tomlkit."""

    @staticmethod
    def _create_mods_array(mods: list[dict[str, Any]]) -> Array | None:
        """
        Creates a tomlkit Array of inline tables for mods.
        This format is required by the ModEngine parser for both natives and packages.
        """
        if not mods:
            return None

        dep_array = tomlkit.array()
        for dep in mods:
            if isinstance(dep, dict) and dep.get("id"):
                inline_table = tomlkit.inline_table()
                inline_table["id"] = dep["id"]
                # Only add 'optional' if it's explicitly true to keep the TOML clean.
                if dep.get("optional") is True:
                    inline_table["optional"] = True
                else:
                    # Per the schema, optional is required. Default to false if not present or false.
                    inline_table["optional"] = False
                dep_array.append(inline_table)
            elif isinstance(dep, str):  # Legacy support for simple strings
                inline_table = tomlkit.inline_table()
                inline_table["id"] = dep
                inline_table["optional"] = False
                dep_array.append(inline_table)

        return dep_array

    @staticmethod
    def write_profile(
        profile_path: Path,
        config_data: dict[str, Any],
        game_name: str | None = None,
    ) -> None:
        """
        Write a ME3 profile file with clean array of tables syntax using tomlkit.

        Args:
            profile_path: Path to write the profile to
            config_data: Dictionary containing profile data
            game_name: Optional game name for context
        """
        # Determine profile version to write
        requested_version = str(config_data.get("profileVersion", "v1")).lower()

        # Create a new TOML document
        doc = tomlkit.document()

        # Add header comment
        doc.add(tomlkit.comment("Profile generated by ME3 Manager"))
        doc.add(tomlkit.nl())
        doc.add("profileVersion", requested_version)

        # Add optional global settings only for v1. For v2 these go under [game]
        if requested_version != "v2":
            if "savefile" in config_data and config_data["savefile"]:
                doc.add("savefile", config_data["savefile"])
            if "start_online" in config_data:
                doc.add("start_online", config_data["start_online"])
            if "disable_arxan" in config_data:
                doc.add("disable_arxan", config_data["disable_arxan"])

        # Add supports section (v1) as an array of tables
        if requested_version != "v2":
            supports = config_data.get("supports", [])
            # If missing/empty, infer a default from game_name
            if (not supports) and game_name:
                try:
                    slug = "".join(ch for ch in str(game_name).lower() if ch.isalnum())
                    if slug:
                        supports = [{"game": slug}]
                except Exception:
                    supports = supports or []
            if supports:
                supports_aot = tomlkit.aot()
                for support in supports:
                    if isinstance(support, dict):
                        support_table = tomlkit.table()
                        for k, v in support.items():
                            support_table[k] = v
                        supports_aot.append(support_table)
                    elif isinstance(support, str):
                        support_table = tomlkit.table()
                        support_table["game"] = support
                        supports_aot.append(support_table)
                doc.add("supports", supports_aot)

        if requested_version == "v2":
            # v2 layout: [game] and [mods]
            v2_dict = ProfileConverter.to_v2(config_data, game_name)

            # Write [game]
            game_tbl = v2_dict.get("game")
            if isinstance(game_tbl, dict) and game_tbl:
                game_table = tomlkit.table()
                for k, v in game_tbl.items():
                    game_table[k] = v
                doc.add("game", game_table)

            # Write [mods]
            deps = v2_dict.get("mods", {})
            if isinstance(deps, dict) and deps:
                deps_table = tomlkit.table()
                # For inline tables with nested dicts, preserve dotted keys where appropriate
                for ident, val in deps.items():
                    if isinstance(val, dict):
                        inline_tbl = tomlkit.inline_table()

                        def _flatten_into_inline(
                            prefix: str, dct: dict[str, Any], target
                        ):
                            for sk, sv in dct.items():
                                if isinstance(sv, dict):
                                    _flatten_into_inline(f"{prefix}.{sk}", sv, target)
                                else:
                                    target[f"{prefix}.{sk}"] = sv

                        for key, v in val.items():
                            if isinstance(v, dict):
                                _flatten_into_inline(key, v, inline_tbl)
                            else:
                                inline_tbl[key] = v
                        # Attach the inline table to mods table under the identifier
                        deps_table[ident] = inline_tbl
                    else:
                        deps_table[ident] = val
                doc.add("mods", deps_table)

            # Write file
            with open(profile_path, "w", encoding="utf-8") as f:
                toml_content = tomlkit.dumps(doc)
                # Remove quotes from dotted keys in mods inline tables
                import re

                toml_content = re.sub(
                    r'("(?:initializer|finalizer)\.[^"]+")\s*=\s*',
                    lambda m: f"{m.group(1)[1:-1]} = ",
                    toml_content,
                )
                f.write(toml_content)
            return

        # Add natives section (v1)
        natives = config_data.get("natives", [])
        if natives:
            natives_aot = tomlkit.aot()

            for native in natives:
                if isinstance(native, dict):
                    native_table = tomlkit.table()

                    if "path" in native:
                        native_table["path"] = native["path"]
                    if native.get("optional"):
                        native_table["optional"] = True

                    if "load_before" in native:
                        dep_array = TomlProfileWriter._create_mods_array(
                            native["load_before"]
                        )
                        if dep_array:
                            native_table["load_before"] = dep_array
                    if "load_after" in native:
                        dep_array = TomlProfileWriter._create_mods_array(
                            native["load_after"]
                        )
                        if dep_array:
                            native_table["load_after"] = dep_array

                    if "initializer" in native and native["initializer"]:
                        # Use dotted key notation instead of nested tables
                        initializer = native["initializer"]
                        if isinstance(initializer, dict):
                            for key, value in initializer.items():
                                if isinstance(value, dict):
                                    # Handle nested structures like delay.ms
                                    for nested_key, nested_value in value.items():
                                        # Use string key - post-processing will remove quotes
                                        dotted_key = f"initializer.{key}.{nested_key}"
                                        native_table[dotted_key] = nested_value
                                else:
                                    dotted_key = f"initializer.{key}"
                                    native_table[dotted_key] = value
                        else:
                            native_table["initializer"] = initializer

                    if "finalizer" in native and native["finalizer"]:
                        # Use dotted key notation instead of nested tables
                        finalizer = native["finalizer"]
                        if isinstance(finalizer, dict):
                            for key, value in finalizer.items():
                                if isinstance(value, dict):
                                    # Handle nested structures like delay.ms
                                    for nested_key, nested_value in value.items():
                                        # Use string key - post-processing will remove quotes
                                        dotted_key = f"finalizer.{key}.{nested_key}"
                                        native_table[dotted_key] = nested_value
                                else:
                                    dotted_key = f"finalizer.{key}"
                                    native_table[dotted_key] = value
                        else:
                            native_table["finalizer"] = finalizer

                    natives_aot.append(native_table)

                elif isinstance(native, str):
                    native_table = tomlkit.table()
                    native_table["path"] = native
                    natives_aot.append(native_table)

            doc.add("natives", natives_aot)

        # Add packages section (v1)
        packages = config_data.get("packages", [])
        if packages:
            packages_aot = tomlkit.aot()

            for package in packages:
                if isinstance(package, dict):
                    package_table = tomlkit.table()

                    if "id" in package:
                        package_table["id"] = package["id"]
                    if "path" in package:
                        package_table["path"] = package["path"]
                    elif "source" in package:  # Legacy support
                        package_table["path"] = package["source"]

                    if "load_before" in package:
                        dep_array = TomlProfileWriter._create_mods_array(
                            package["load_before"]
                        )
                        if dep_array:
                            package_table["load_before"] = dep_array
                    if "load_after" in package:
                        dep_array = TomlProfileWriter._create_mods_array(
                            package["load_after"]
                        )
                        if dep_array:
                            package_table["load_after"] = dep_array

                    packages_aot.append(package_table)

            doc.add("packages", packages_aot)

        # Write to file (v1)
        with open(profile_path, "w", encoding="utf-8") as f:
            toml_content = tomlkit.dumps(doc)
            # Post-process to remove quotes from dotted keys
            import re

            # Remove quotes from dotted keys like "initializer.delay.ms" = value
            toml_content = re.sub(
                r'"((?:initializer|finalizer)\.[\w.]+)"\s*=', r"\1 =", toml_content
            )
            f.write(toml_content)

    @staticmethod
    def format_inline_to_aot(content: str) -> str:
        """
        Convert inline array syntax to array of tables syntax.
        This is a utility method for migrating existing profiles.

        Args:
            content: TOML content with inline arrays

        Returns:
            TOML content with array of tables
        """
        try:
            import tomllib

            # Parse the existing content
            config_data = tomllib.loads(content)

            # Use our writer to create the new format
            import tempfile

            with tempfile.NamedTemporaryFile(
                mode="w", suffix=".me3", delete=False
            ) as tmp:
                tmp_path = Path(tmp.name)

            try:
                TomlProfileWriter.write_profile(tmp_path, config_data)
                with open(tmp_path, "r", encoding="utf-8") as f:
                    result = f.read()
                return result
            finally:
                tmp_path.unlink(missing_ok=True)

        except Exception as e:
            log.error("Error converting TOML format: %s", e)
            return content  # Return original if conversion fails
